import arc.files.Fi

import java.util.function.Consumer

buildscript {
    repositories {
        mavenCentral()
        maven { url "https://www.jitpack.io" }
        maven { url "https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository" }
    }

    dependencies {
        classpath "com.github.Anuken.Arc:arc-core:v146"
    }
}

allprojects.each { Project project ->
    project.plugins.apply("java")
    project.plugins.apply("idea")
    project.plugins.apply("maven-publish")

    project.version = properties.get("version")
    project.group = properties.get("group")
}

wrapper {
    gradleVersion = "8.1.1"
}

sourceSets.main.java.srcDirs = []
sourceSets.main.resources.srcDirs = []

task cleanBuilds(type: Delete) {
    doLast {
        subprojects.each { Project p ->
            if (p.buildDir.exists()) {
                delete(p.buildDir)
            }
        }
    }
}

class C extends OutputStream {
    static String out = ""

    @Override
    void write(int b) throws IOException {
        out += String.valueOf((char) b)
    }

    static String get() {
        String t = out
        out = ""
        return t
    }

    @Override
    String toString() {
        return out
    }
}

static String getVersion(String dependence) {
    return dependence.substring(dependence.lastIndexOf(":")+1)
}

ext {
    modConfig = new Fi(rootProject.file("mod.hjson"))

    copyProperties = new Properties()
    if (rootProject.file("copy.properties").exists())
        copyProperties.load(new FileInputStream(rootProject.file("copy.properties")))

    localProperties = new Properties()
    if (new File("$rootProject.projectDir/local.properties").exists())
        localProperties.load(new FileInputStream(new File("$rootProject.projectDir/local.properties")))

    dependenciesI = new HashMap<Project, String>()
    dependenciesC = new HashMap<Project, String>()
    dependenciesA = new HashMap<Project, String>()
    dependencies = new HashMap<String, String>()
    dependenciesProperties = new Properties()
    var file = new File("$rootProject.projectDir/dependencies.properties")
    dependenciesProperties.load(new InputStreamReader(new FileInputStream(file)))
    dependenciesProperties.forEach((k, v) -> {
        if (k.length() > 2) {
            switch (k.substring(k.length()-2)) {
                case "-C":
                    dependenciesC.put(project(k.substring(0, k.length()-2)), v)
                    break
                case "-I":
                    dependenciesI.put(project(k.substring(0, k.length()-2)), v)
                    break
                case "-A":
                    dependenciesA.put(project(k.substring(0, k.length()-2)), v)
                    break
                default:
                    dependencies.put(k, v)
            }
        } else {
            dependencies.put(k, v)
        }
    })

    setIfHasProp = { String property, Consumer<Object> set ->
        if (localProperties.containsKey(property))
            set.accept(localProperties.get(property))
    }

    doExec = { String cmd ->
        C.get()
        var proc = cmd.execute(null, rootProject.projectDir)
        proc.waitForProcessOutput(new PrintStream(new C()), System.err)
    }

    getOutputJar = {Project p ->
        return "${rootProject.name}-${p.name}-${p.version}.jar"
    }

    // WIP
    getLastestVersion = { String dep ->
        BufferedReader reader = new BufferedReader(
                new InputStreamReader(new URL("https://jitpack.io/com/github/$dep/").openStream()))
        String line, latestVersion
        println reader.readLine()
        while ((line = reader.readLine()) != null) {
            println line
            if (line.matches(".?[0-9.]+[/]?")) {
                println line
                latestVersion = line.substring(0, line.length()-1)
            }
        }
        return latestVersion
    }

    // key word for natives searching
    // paste as comment to file that's needs natives
    nativesTrigger = "nt_gdrl_trigger"

    mindustryDependencyType = rootProject.properties.get("mindustryDependencyType")
    mindustryVersion = rootProject.properties.get("mindustryVersion")
    arcVersion = rootProject.properties.get("arcVersion")

    if (mindustryVersion == "-")
        mindustryVersion = getLastestVersion("Anuken/$mindustryDependencyType")
    if (arcVersion == "-")
        arcVersion = getLastestVersion("Anuken/Arc")
}

subprojects.each { Project project ->
    // Anuke
    project.configurations.all {
        resolutionStrategy.eachDependency { details ->
            if(details.requested.group == "com.github.Anuken.Arc"){
                String version = ""
                if (rootProject.ext.dependenciesC.containsKey(project))
                    rootProject.ext.dependenciesC.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }
                if (rootProject.ext.dependenciesI.containsKey(project))
                    rootProject.ext.dependenciesI.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }
                if (rootProject.ext.dependenciesA.containsKey(project))
                    rootProject.ext.dependenciesA.get(project).split(";").each { String dep ->
                        if (dep.contains("com.github.Anuken.Arc"))
                            version = getVersion(dep)
                    }

                if (version != "")
                    details.useVersion version
            }
        }
    }

    // bin folder only for natives
    project.sourceSets.main.java.srcDirs = [
            "src", "gen", "bin"
    ]
    project.sourceSets.main.resources.srcDirs = [
            "res",
    ]

    project.ext {
        // setup annotation processors properties
        APArgs = ["ProjectName=${project.name}"]
        var src = "ProjectSrc=", res = "ProjectRes="
        project.sourceSets.main.java.srcDirs.each { var str ->
            src += str.toString() + ";"
        }
        project.sourceSets.main.resources.srcDirs.each { var str ->
            res += str.toString() + ";"
        }
        APArgs.add(src.substring(0, src.length()-1))
        APArgs.add(res.substring(0, res.length()-1))
        var APAProps = new Fi(project.file("APA.properties"))
        var GAPAProps = new Fi(rootProject.file("APA.properties"))
        if (GAPAProps.exists()) {
            APArgs += Arrays.stream(GAPAProps.readString().replaceAll("\n", "").replaceAll("\r", "").split(";")).toList()
        }
        if (APAProps.exists()) {
            APArgs += Arrays.stream(APAProps.readString().replaceAll("\n", "").replaceAll("\r", "").split(";")).toList()
        }

        copyPaths = [
                "$rootProject.projectDir/artifacts",
        ]
        if (rootProject.ext.copyProperties.containsKey(project.name))
            copyPaths += Arrays.stream(rootProject.ext.copyProperties.get(project.name).split(";")).toList()

        child = { File p, String c ->
            return new File(p, c)
        }

        classesDir = "$project.buildDir/classes/java/main"
        headersDir = "$project.buildDir/headers"

        writeProcessors = {
            var processorPath = child(project.sourceSets.main.resources.srcDirs.getAt(0), "META-INF/services/")
            processorPath.mkdirs()
            var processorFile = child(processorPath, ("javax.annotation.processing.Processor"))
            var text = new StringBuilder()
            var srcFiles = project.sourceSets.main.java.srcDirs.getAt(0)
            if (srcFiles.exists()) {
                srcFiles.eachFileRecurse(groovy.io.FileType.FILES) { file ->
                    if (file.name.endsWith(".java") && file.text.contains("@AnnotationProcessor")) {
                        text.append(file.path.substring(srcFiles.path.length() + 1)).append("\n")
                    }
                }
            }
            processorFile.text = text.toString().replace(".java", "").replace("/", ".").replace("\\", ".")
        }
    }

    project.repositories {
        mavenCentral()
        maven { url "https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository" }
        maven { url "https://www.jitpack.io" }
    }

    project.dependencies {
        annotationProcessor "com.github.Anuken:jabel:93fde537c7"
    }

    project.tasks.create("compileHeaders") {
        doLast {
            def command = ""
            project.sourceSets.main.java.srcDirs.each { dir ->
                if (dir.exists()) {
                    dir.eachFileRecurse(groovy.io.FileType.FILES) { file ->
                        if (file.text.contains("$rootProject.ext.nativesTrigger")) {
                            def path = file.absolutePath//.substring(dir.absolutePath.length())
                            //path = "${project.ext.classesDir.substring(rootProject.projectDir.absolutePath.length()+1)}$path"
                            command += "\"$path\" "
                        }
                    }
                }
            }

            if (command.length() > 0) {
                var classpath = (project.configurations.compileClasspath.asList()
                        + project.configurations.runtimeClasspath.asList()
                            + project.sourceSets.main.java.srcDirs.asList())
                var dependencies = String.join(";", classpath.path)

                command = "javac -cp $dependencies -h \"$project.ext.headersDir\" " + command
                println command
                rootProject.ext.doExec(command)
                println C.get()
            } else {
                println "No headers founded for project $project."
            }
        }

        project.tasks.withType(JavaCompile) {
            //finalizedBy project.tasks.compileHeaders
        }
    }

    project.tasks.withType(JavaCompile) {
        rootProject.ext.setIfHasProp("org.gradle.java.home", v -> options.forkOptions.executable = v)
        var finalAPArgs = []
        project.ext.APArgs.each { String str ->
            if (!str.contains("-A"))
                finalAPArgs.add("-A" + str)
        }

        options.encoding = "UTF-8"
        options.compilerArgs += ["-Xlint:none"]
        options.compilerArgs += finalAPArgs
        options.compilerArgs.addAll(['--release', '8'])
        options.generatedSourceOutputDirectory.set(project.file("gen"))
        options.forkOptions.jvmArgs.addAll([
                "--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED",
                "--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
                "--add-opens=java.base/sun.reflect.annotation=ALL-UNNAMED"
        ])

        targetCompatibility = 8
        sourceCompatibility = JavaVersion.VERSION_16

        doFirst {
            delete options.generatedSourceOutputDirectory.get().asFile.listFiles()
        }
    }

    project.tasks.create("copyJar") {
        doLast {
            project.ext.copyPaths.each { p ->
                copy {
                    from project.tasks.jar
                    into p
                }
            }
        }
    }

    project.tasks.jar {
        archiveFileName = rootProject.ext.getOutputJar(project)

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        from {
            project.configurations.runtimeClasspath.collect { File file ->
                file.isDirectory() ? file : zipTree(file)
            }
        }

        finalizedBy project.tasks.copyJar
    }

    project.java {
        withSourcesJar()
        withJavadocJar()
    }

    project.publishing {
        publications {
            maven(MavenPublication) {
                groupId "github.${project.group.replaceAll("/", ".")}"
                artifactId project.name
                version project.version
                from components.java
                println "Dependency path for project ${project} is ${groupId}:${artifactId}:${version}"
            }
        }
    }
}

task publishProj {
    doLast {
        publishToMavenLocal
    }
}

task deploy {
    dependsOn subprojects.stream().<Task>map(p -> p.tasks.jar).toArray()
    // FIXME sucks on Windows
    //finalizedBy rootProject.tasks.cleanBuilds
}

task workflowCommit {
    dependsOn deploy
}

// TODO remove useless task
task buildRelease(type: Jar) {
    dependsOn deploy

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    from {
        zipTree("artifacts/" + rootProject.ext.getOutputJar(project(":android")))
        zipTree("artifacts/" + rootProject.ext.getOutputJar(project(":desktop")))
    }

    doLast {
        def copyPaths = [
                "$rootProject.projectDir/artifacts",
        ]
        if (rootProject.ext.copyProperties.containsKey("release"))
            copyPaths += Arrays.stream(rootProject.ext.copyProperties.get("release").split(";")).toList()

        copyPaths.each { p ->
            copy {
                from {
                    project.tasks.jar.archiveFile.get()
                }
                into(p)
            }
        }
    }
}

// only for local machine (WIP)
task createRelease {
    dependsOn deploy

    doLast {
        var vers = new Properties()
        vers.load(new FileInputStream(project.file("version.properties")))
        var descr = ""

        if (vers.containsKey("description"))
            descr = vers.get("description")

        var un = "", ue = "", ut = ""
        var tagName = project.version

        // setup github user
        setIfHasProp("username", v -> un = v)
        setIfHasProp("useremail", v -> ue = v)
        setIfHasProp("usertoken", v -> ut = v)
        doExec("git config user.name $un --replace-all")
        doExec("git config user.email $ue --replace-all")
        var addr = "https://$un:$ut@github.com/${project.group}.git"

        // delete older tag with same name
        doExec("git tag")
        var tags = C.get().split("\n")
        if (Arrays.stream(tags).toList().contains(tagName)) {
            doExec("git tag -d $tagName")
            doExec("git push $addr -d tag $tagName")
            C.print()
        }

        // push new tag
        doExec("git tag -a $tagName -m \"${descr}")
        doExec("git push $addr main $tagName")
    }
}
